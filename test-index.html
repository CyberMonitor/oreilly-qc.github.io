<!DOCTYPE html>
<html lang="en">
<head>
  <title>Programming Quantum Computers</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>
  <script src="./external/ace/src-min-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>

<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorA: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_bitfield.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorB: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_reg.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<!-- <script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_int.js"></script>
 -->











 <script type="text/javascript">
   
/////////////////////////////////////////////////////////////////////////////
// qcengine_int.js
// Copyright 2000-2011 Eric Johnston
// qcengine@machinelevel.com
//
//  License:
//    (This is similar to the zlib license, with item 4 added and modifications
//     which apply only to commercial use.) 
//
//  This software is provided 'as-is', without any express or implied
//  warranty. In no event will the authors be held liable for any damages
//  arising from the use of this software.
//
//  Commercial use requires written authorization from the author.
//  Please contact me, as I can also help make sure you're getting the best use
//  from this software, and have the most up-to-date version.
//
//  Permission is granted to anyone to use this software for non-commercial
//  purposes, and to alter it and redistribute it freely, subject to the
//  following restrictions:
//
//  1. The origin of this software must not be misrepresented; you must not
//     claim that you wrote the original software. If you use this software
//     in a product, an acknowledgment in the product documentation would be
//     appreciated but is not required.
//  2. Altered source versions must be plainly marked as such, and must not be
//     misrepresented as being the original software.
//  3. This notice may not be removed or altered from any source distribution.
//  4. If you find this material useful, I'd love to know. If there is an email
//     address listed above this notice, please consider sending me a note.
//  (end of license text)
//
//  Commercial interest: There are several versions of this software, each
//  designed to maximize speed under different hardware and/or language constraints.
//  For more info, please contact me at qcengine@machinelevel.com
//

/////////////////////////////////////////////////////////////////////////////
// The QInt class simulates multi-qubit signed and unsigned integers.
//   numBits  the integer size in bits (any positive integer)
//   qReg     the QReg to use for storage. This may be active or inactive.

function make_sub_int(parent, name, sub_start, num_bits)
{
   var new_qint = new QInt(num_bits, parent.qReg, name);

   new_qint.startBit = parent.startBit + sub_start;
   new_qint.baseMask = 0;
   for (var i = 0; i < new_qint.numBits; ++i)
       new_qint.baseMask |= 1 << i;
   new_qint.maskBF = newShiftedMask(new_qint.baseMask, new_qint.startBit);
   new_qint.valid = true;
   return new_qint;
}

  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC1: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

function Qubits(numBits, name=null, qReg=null)
{
    // Arg flexibility: allow qreg to be passed in name slot
    if (qReg == null && name && name.qReg)
    {
        qReg = name;
        name = null;
    }

    if (numBits == 0)
        return null;
 
    numBits = 0|numBits;
    this.valid = false;            // true if this int is ready to use
    this.numBits = numBits;        // the number of bits in this integer

    // Accept either "qc" or "qc.qReg" here
    if (qReg.qReg)
    {
        this.qpu = qReg;
        qReg = qReg.qReg;
    }

    // Handle the case where no name is passed in
    this.auto_name_prefix = 'q';
    if (this.qpu && !name)
        name = this.auto_name_prefix + this.qpu.next_qint_serial_number();

    this.qReg = qReg;
    this.isUtil = false;
    if (name == '(util)')
    {
        this.isUtil = true;
        qReg.utilityInts.push(this);
    }
    qReg.qInts.push(this);
    this.name = name;
    this.isUtil = false;
    this.isQInt = true;

    //
    // methods
    //

    // reserve() is called to reserve the qubits for this int.
    // This is called automatically on construction.
    this.reserve = function ()
    {
        if (!this.valid)
        {
            this.startBit = qReg.reserveBits(this.numBits);
            if (this.startBit >= 0)
            {
                this.baseMask = 0;
                for (var i = 0; i < this.numBits; ++i)
                    this.baseMask |= 1 << i;
                this.maskBF = newShiftedMask(this.baseMask, this.startBit);
                this.valid = true;
            }
        }
        this.qReg.qIntsChanged();
    }


    // release() is called to give up the qubits allocated to this int.
    this.release = function ()
    {
        if (this.valid)
        {
            this.valid = false;
            this.qReg.releaseBits(this.numBits, this.startBit);
        }
    }

    this.getValueProbability = function (value)
    {
        if (this.valid)
        {
            var regValue = value << this.startBit;
            var qx = this.qReg.vector[0][regValue];
            var qy = this.qReg.vector[1][regValue];
            return qx * qx + qy * qy;
        }
        return 0;
    }

    this.getValuePhaseRadians = function (value)
    {
        if (this.valid)
        {
            var regValue = value << this.startBit;
            var qx = this.qReg.vector[0][regValue];
            var qy = this.qReg.vector[1][regValue];
            return Math.atan2(qy, qx);
        }
        return 0;
    }

    this.peekComplexValue = function (value)
    {
        if (this.valid)
        {
            var regValue = value << this.startBit;
            return this.qReg.peekComplexValue(regValue);
        }
        return 0;
    }

    this.peekProbability = function (value, cval_array)
    {
        if (this.valid)
        {
            var regValue = value << this.startBit;
            var bitsBelow = this.startBit;
            var bitsAbove = this.qReg.numQubits - (this.startBit + this.numBits);
            var probability = 0;
            for (below = 0; below < 1 << bitsBelow; ++below)
            {
                for (above = 0; above < 1 << bitsAbove; ++above)
                {
                    var checkValue = regValue | below | (above << (this.startBit + this.numBits));
                    var complexValue = this.qReg.peekComplexValue(checkValue);
                    var prob = complexValue.x * complexValue.x + complexValue.y * complexValue.y;
                    probability += prob;
                    if (cval_array && prob > 0.000001)
                        cval_array.push(complexValue);
                }
            }
            return probability;
        }
        return 0;
    }

    this.printProbabilities = function(message, start, count)
    {
        if (message == null)
            message = '';
        if (start == null)
            start = 0;
        if (count == null)
            count = 1 << this.numBits;
        var str = '' + this.name + ': ' + message + ' ';
        for (var i = start; i < count; ++i)
        {
            var val = this.peekProbability(i);
            if (val != 0)
                str += '[' + i + ']=' + val.toFixed(6) + ' ';
        }
        console.log(str);
    }

    this.peekHighestProbability = function(start, count)
    {
        if (start == null)
            start = 0;
        if (count == null)
            count = 1 << this.numBits;

        var best_val = start;
        var best_prob = 0;
        for (var i = start; i < count; ++i)
        {
            var prob = this.peekProbability(i);
            if (prob > best_prob)
            {
                best_prob = prob;
                best_val = i;
            }
        }
        return best_val;
    }

    // NOTE: this does a cnot between corresponding qubits in the qint.
    // It's useful for expanding programs to larger bytes.
    // Two qints of any size can be swapped with three of these.
    this.cnot_core = function (op, conditionInt, targ_mask, extraConditionBits, extraNOTConditionBits)
    {
        // Special simple common syntax
        if (conditionInt && !is_qint(conditionInt))
        {
            // In this case, it's myint.cnot(target, cond)
            extraConditionBits = this.bits(targ_mask);
            targ_mask = conditionInt;
            conditionInt = null;
        }
        var anim = this.qReg.animateWidgets;

        if (extraNOTConditionBits)
        {
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
            else
                this.qReg.not(extraNOTConditionBits);
        }

        var condition = NewBitField(0, this.qReg.numQubits);
        var baseTarget = (targ_mask == null) ? this.baseMask : this.baseMask & targ_mask;
        if (!conditionInt)
        {
            condition.set(0);
            condition.orEquals(extraConditionBits);
            condition.orEquals(extraNOTConditionBits);
            var bt = qintMask([this, baseTarget]);
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('cnot', bt, condition, 0);
            else
                this.qReg.cnot(bt, condition);
            bt.recycle();
        }
        else
        {
            var target = NewBitField(0, this.qReg.numQubits);
            var bits = this.numBits;
            if (conditionInt && conditionInt.numBits < bits)
                bits = conditionInt.numBits;
            for (var i = 0; i < bits; ++i)
            {
                if (baseTarget & (1 << i))
                {
                    target.set(0);
                    target.setBits(i + this.startBit, 1, 1);
                    condition.set(0);
                    if (conditionInt)
                        condition.setBits(i + conditionInt.startBit, 1, 1);
                    condition.orEquals(extraConditionBits);
                    condition.orEquals(extraNOTConditionBits);
    //TODO1                conditionMask |= extraConditionBits | extraNOTConditionBits;
           //         this.qReg.cnot(targetMask, conditionMask);
                    if (anim)
                        this.qReg.staff.addInstructionAfterInsertionPoint(op, target, condition, 0);
                    else
                    {
                        if (op == 'cnot')
                            this.qReg.cnot(target, condition);
                        else if (op == 'crootnot')
                            this.qReg.crootnot(target, condition);
                        else if (op == 'crootnot_inv')
                            this.qReg.crootnot_inv(target, condition);
                    }
                }
            }
            target.recycle();
        }
        condition.recycle();
        if (extraNOTConditionBits)
        {
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
            else
                this.qReg.not(extraNOTConditionBits);
        }
    }

    this.not = function (mask)
        { this.cnot_core('cnot', null, mask, null, null); }
    this.cnot = function (conditionInt, mask, extraConditionBits, extraNOTConditionBits)
        { this.cnot_core('cnot', conditionInt, mask, extraConditionBits, extraNOTConditionBits); }
    this.rootnot = function (mask)
        { this.cnot_core('crootnot', null, mask, null, null); }
    this.crootnot = function (conditionInt, mask, extraConditionBits, extraNOTConditionBits)
        { this.cnot_core('crootnot', conditionInt, mask, extraConditionBits, extraNOTConditionBits); }
    this.rootnot_inv = function (mask)
        { this.cnot_core('crootnot_inv', null, mask, null, null); }
    this.crootnot_inv = function (conditionInt, mask, extraConditionBits, extraNOTConditionBits)
        { this.cnot_core('crootnot_inv', conditionInt, mask, extraConditionBits, extraNOTConditionBits); }

    this.rootx = function (mask)
        { this.cnot_core('crootnot', null, mask, null, null); }
    this.crootx = function (conditionInt, mask, extraConditionBits, extraNOTConditionBits)
        { this.cnot_core('crootnot', conditionInt, mask, extraConditionBits, extraNOTConditionBits); }
    this.rootx_inv = function (mask)
        { this.cnot_core('crootnot_inv', null, mask, null, null); }
    this.crootx_inv = function (conditionInt, mask, extraConditionBits, extraNOTConditionBits)
        { this.cnot_core('crootnot_inv', conditionInt, mask, extraConditionBits, extraNOTConditionBits); }

    this.exchange_core = function (op, swapInt, baseMask, extraConditionBits, extraNOTConditionBits)
    {
        // convert any qint extra cond args to bitfields
        if (extraConditionBits && extraConditionBits.isQInt)
            extraConditionBits = extraConditionBits.maskBF;
        if (extraNOTConditionBits && extraNOTConditionBits.isQInt)
            extraNOTConditionBits = extraNOTConditionBits.maskBF;

        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
        if (baseMask == null) // null is different from zero! It means no value was passed.
            baseMask = this.baseMask;

        var conditionMask = 0;
        if (!(isAllZero(extraConditionBits) && isAllZero(extraNOTConditionBits)))
        {
            if (conditionMask)
            {
                conditionMask = NewBitField(extraConditionBits);
                conditionMask.orEquals(extraNOTConditionBits);
            }
            else
            {
                conditionMask = NewBitField(extraNOTConditionBits);
                conditionMask.orEquals(extraConditionBits);
            }
        }
        var bits = this.numBits;

        targetBits = NewBitField(0, this.qReg.numQubits);

        if (swapInt == null || swapInt == this)
        {
            targetBits.set(0);
            for (var i = 0; i < bits; ++i)
            {
                if (baseMask & (1 << i))
                {
                    targetBits.setBit(i + this.startBit, 1);
                }
            }
            this.qReg.staff.addInstructionAfterInsertionPoint(op, targetBits, conditionMask, 0);
        }
        else
        {
            if (swapInt.numBits < bits)
                bits = swapInt.numBits;
            for (var i = 0; i < bits; ++i)
            {
                if (baseMask & (1 << i))
                {
                    targetBits.set(0);
                    targetBits.setBit(i + this.startBit, 1);
                    targetBits.setBit(i + swapInt.startBit, 1);
                    this.qReg.staff.addInstructionAfterInsertionPoint(op, targetBits, conditionMask, 0);
                }
            }
        }
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
    }

    this.exchange = function (swapInt, baseMask, extraConditionBits, extraNOTConditionBits)
    {
        this.exchange_core('exchange', swapInt, baseMask, extraConditionBits, extraNOTConditionBits);
    }
    this.swap = this.exchange;
    this.cswap = this.exchange;

    this.rootexchange = function (swapInt, baseMask, extraConditionBits, extraNOTConditionBits)
    {
        this.exchange_core('rootexchange', swapInt, baseMask, extraConditionBits, extraNOTConditionBits);
    }

    this.rootexchange_inv = function (swapInt, baseMask, extraConditionBits, extraNOTConditionBits)
    {
        this.exchange_core('rootexchange_inv', swapInt, baseMask, extraConditionBits, extraNOTConditionBits);
    }

    this.y = function (mask, extraConditionBits)
        { this.qpu.y(this.mask(mask)) }
    this.cy = this.y;

    this.hadamard = function (mask, extraConditionBits)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('hadamard', target, extraConditionBits);
    }
    this.had = this.hadamard; // more convenient

    this.chadamard = function (conditionInt, mask, extraConditionBits, extraNOTConditionBits)
    {
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);

        var condition = NewBitField(0, this.qReg.numQubits);
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        if (!conditionInt)
        {
            condition.set(0);
            condition.orEquals(extraConditionBits);
            condition.orEquals(extraNOTConditionBits);
            var bt = qintMask([this, baseTarget]);
            this.qReg.staff.addInstructionAfterInsertionPoint('chadamard', bt, condition, 0);
            bt.recycle();
        }
        else
        {
            var target = NewBitField(0, this.qReg.numQubits);
            var bits = this.numBits;
            if (conditionInt && conditionInt.numBits < bits)
                bits = conditionInt.numBits;
            for (var i = 0; i < bits; ++i)
            {
                if (baseTarget & (1 << i))
                {
                    target.set(0);
                    target.setBits(i + this.startBit, 1, 1);
                    condition.set(0);
                    if (conditionInt)
                        condition.setBits(i + conditionInt.startBit, 1, 1);
                    condition.orEquals(extraConditionBits);
                    condition.orEquals(extraNOTConditionBits);
    //TODO1                conditionMask |= extraConditionBits | extraNOTConditionBits;
           //         this.qReg.cnot(targetMask, conditionMask);
                    this.qReg.staff.addInstructionAfterInsertionPoint('chadamard', target, condition, 0);
                }
            }
        }
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
    }
    this.chad = this.chadamard; // more convenient

    this.beamsplitter = function (reflectivity, mask)
    {
        if (reflectivity == null)
            reflectivity = 0.5;
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('optical_beamsplitter', target, null, reflectivity);
    }

    this.dual_rail_beamsplitter = function (reflectivity, mask)
    {
        if (reflectivity == null)
            reflectivity = 0.5;
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('dual_rail_beamsplitter', target, null, reflectivity);
    }

    this.pbs = function (hoiz_vert, mask)
    {
        if (reflectivity == null)
            reflectivity = 0.5;
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('pbs', target, null, horiz_vert);
    }

    this.postselect_qubit_pair = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = null;

        // If the arg is a qint, then make pair qubits between them
        if (mask && mask.isQInt)
        {
            target = newShiftedMask(1, this.startBit);
            target.setBit(mask.startBit, 1);
        }
        else
            target = newShiftedMask(baseTarget, this.startBit);

        this.qReg.staff.addInstructionAfterInsertionPoint('postselect_qubit_pair', target);
    }

    this.pair_source = function (mask)
    {
        // If the arg is a qint, then make pair sources between corresponding bits
        if (mask.isQInt)
            return this.cnot_core('pair_source', mask, null, null, null);

        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('pair_source', target, null, 0);
    }

    this.polarization_grating_in = function (mask, theta)
    {
        if (theta == null)
            theta = 0.0;
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('polarization_grating_in', target, null, theta);
    }

    this.polarization_grating_out = function (mask, theta)
    {
        if (theta == null)
            theta = 0.0;
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('polarization_grating_out', target, null, theta);
    }

    this.phase = function (thetaDegrees, targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        // convert any qint extra cond args to bitfields
        if (extraConditionBits && extraConditionBits.isQInt)
            extraConditionBits = extraConditionBits.maskBF;
        if (extraNOTConditionBits && extraNOTConditionBits.isQInt)
            extraNOTConditionBits = extraNOTConditionBits.maskBF;

        var baseTarget = (targetMask == null) ? this.baseMask : this.baseMask & targetMask;
        var baseCondition = (conditionMask == null) ? 0 : this.baseMask & conditionMask;
        var target = newShiftedMask(baseTarget, this.startBit);
        var condition = newShiftedMask(baseCondition, this.startBit);
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
        condition.orEquals(extraConditionBits);
        condition.orEquals(extraNOTConditionBits);
        this.qReg.staff.addInstructionAfterInsertionPoint('phase', target, condition, thetaDegrees);
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
    }


    this.cphase_intarg = function (thetaDegrees, condInt, targetMask, extraConditionBits, extraNOTConditionBits)
    {
        // convert any qint extra cond args to bitfields
        if (extraConditionBits && extraConditionBits.isQInt)
            extraConditionBits = extraConditionBits.maskBF;
        if (extraNOTConditionBits && extraNOTConditionBits.isQInt)
            extraNOTConditionBits = extraNOTConditionBits.maskBF;

        var baseTarget = (targetMask == null) ? this.baseMask : this.baseMask & targetMask;
        var baseCondition = baseTarget & condInt.baseMask;
        baseTarget &= baseCondition;
        var targ_hi = getHighestBitIndex(baseTarget);
        var targ_lo = getLowestBitIndex(baseTarget);
        if (targ_lo != targ_hi)
        {
            // If we have multiple target qubits, run them as separate ops
            for (var targ_bit = targ_lo; targ_bit <= targ_hi; ++targ_bit)
            {
                var tmask = 1 << targ_bit;
                if (baseTarget & tmask)
                    this.cphase(thetaDegrees, condInt, tmask, extraConditionBits, extraNOTConditionBits);
            }
            return;
        }
        var target = newShiftedMask(baseTarget, this.startBit);
        var condition = newShiftedMask(baseCondition, condInt.startBit);
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
        condition.orEquals(extraConditionBits);
        condition.orEquals(extraNOTConditionBits);
        this.qReg.staff.addInstructionAfterInsertionPoint('phase', target, condition, thetaDegrees);
        if (extraNOTConditionBits)
            this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
    }

    // TODO: Should these two be allowed to take int args like cx?
    this.cphase = function (thetaDegrees, condition_int=null, target_mask=null, extraConditionBits=null)
    {
        if (is_qint(condition_int)) 
        {
            if (target_mask == null)
                target_mask = ~0;
            // If the first arg is an int, then cphase the corresponding qubits of both ints
            for (var bit_index = 0; bit_index < this.numBits && bit_index < condition_int.numBits; ++bit_index)
            {
                var bit = 1 << bit_index;
                if (bit & target_mask)
                    this.qpu.phase(thetaDegrees, this.bits(bit), condition_int.bits(bit, extraConditionBits));
            }
        }
        else
        {
            // Otherwise, treat the mask as local to this qint 
            extraConditionBits = target_mask;
            target_mask = condition_int;
            if (target_mask == null)
                target_mask = ~0;
            this.qpu.cphase(thetaDegrees, this.bits(target_mask, extraConditionBits));
        }
    }
    this.cz = function (condition_int, target_mask=null, extraConditionBits=null)
    {
        this.cphase(180, condition_int, target_mask, extraConditionBits);
    }

    this.x = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.not(targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }
    this.cx = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.cnot(targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }

    this.z = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.phase(180, targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }
    this.s = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.phase(90, targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }
    this.t = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.phase(45, targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }
    this.s_inv = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.phase(-90, targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }
    this.t_inv = function (targetMask, conditionMask, extraConditionBits, extraNOTConditionBits)
    {
        this.phase(-45, targetMask, conditionMask, extraConditionBits, extraNOTConditionBits);
    }

    this.cs = function (condInt, targetMask, extraConditionBits, extraNOTConditionBits)
    {
        this.cphase_intarg(90, condInt, targetMask, extraConditionBits, extraNOTConditionBits);
    }
    this.ct = function (condInt, targetMask, extraConditionBits, extraNOTConditionBits)
    {
        this.cphase_intarg(45, condInt, targetMask, extraConditionBits, extraNOTConditionBits);
    }
    this.cs_inv = function (condInt, targetMask, extraConditionBits, extraNOTConditionBits)
    {
        this.cphase_intarg(-90, condInt, targetMask, extraConditionBits, extraNOTConditionBits);
    }
    this.ct_inv = function (condInt, targetMask, extraConditionBits, extraNOTConditionBits)
    {
        this.cphase_intarg(-45, condInt, targetMask, extraConditionBits, extraNOTConditionBits);
    }


/*
    this.rootnot = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('rootnot', target, 0, 0);
    }

    this.rootnot_inv = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qReg.staff.addInstructionAfterInsertionPoint('rootnot_inv', target, 0, 0);
    }
*/
    this.rotatex = function (thetaDegrees, mask, cond)
    {
        if (mask && mask.isQInt)
        {
            // Special syntax similar to cnot, arg is another int
            // TODO: replace this with CNOT core
            cond = mask.maskBF;
            mask = null;
        }
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qpu.rx(thetaDegrees, target, cond);
    }

    this.rotatey = function (thetaDegrees, mask, cond)
    {
        if (mask && mask.isQInt)
        {
            // Special syntax similar to cnot, arg is another int
            // TODO: replace this with CNOT core
            cond = mask.maskBF;
            mask = null;
        }
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        this.qpu.ry(thetaDegrees, target, cond);
    }

    this.rotatez = function (thetaDegrees, mask, cond)
    {
        if (mask && mask.isQInt)
        {
            // Special syntax similar to cnot, arg is another int
            // TODO: replace this with CNOT core
            cond = mask.maskBF;
        }
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);
        target.orEquals(cond);
        this.qpu.rz(thetaDegrees, target, cond);
    }

    this.rotate = this.rotatex;
    this.rotx = this.rotatex;
    this.roty = this.rotatey;
    this.rotz = this.rotatez;
    this.rx = this.rotatex;
    this.ry = this.rotatey;
    this.rz = this.rotatez;
    this.crx = this.rotatex;
    this.cry = this.rotatey;
    this.crz = this.rotatez;
    this.crotatex = this.rotatex;
    this.crotatey = this.rotatey;
    this.crotatez = this.rotatez;

    this.teleport_send = function (entangle_qubit)
    {
        entangle_qubit.cnot(this);
        this.hadamard();
        var bits = [this.read(), entangle_qubit.read()];
        return bits;
    }

    this.teleport_receive = function (send_bits)
    {
        this.not(send_bits[0]);
        this.hadamard();
        this.not(send_bits[1]);
        this.hadamard();
    }

    this.read = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);

        if (this.qReg.animateWidgets)
        {
            var instruction = this.qReg.staff.addInstructionAfterInsertionPoint('read', target, 0, 0);
            if (instruction)
                instruction.finish();
        }
        // This result is already cached.
        var rval = intToBitField(this.qReg.read(target));
        var result = rval.getBits(this.startBit, baseTarget);
        target.recycle();
        rval.recycle();
        return result;
    }
    this.read_uint = this.read;

    this.postselect = function (value, mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);

        if (this.qReg.animateWidgets)
        {
            var instruction = this.qReg.staff.addInstructionAfterInsertionPoint('postselect', target, value, 0);
            if (instruction)
                instruction.finish();
        }
        else
        {
            this.qReg.postselect(target, value);
        }
    }

    this.peek = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);

        var instruction = this.qReg.staff.addInstructionAfterInsertionPoint('peek', target, 0, 0);
        if (instruction)
            instruction.finish();
    }

    this.discard = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);

        var instruction = this.qReg.staff.addInstructionAfterInsertionPoint('discard', target, 0, 0);
        if (instruction)
            instruction.finish();
    }

    this.nop = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var target = newShiftedMask(baseTarget, this.startBit);

        var instruction = this.qReg.staff.addInstructionAfterInsertionPoint('nop', target, 0, 0);
        if (instruction)
            instruction.finish();
    }

    // Just return a shifted bitmask to use as args
    this.bits = function (mask, or_with_next)
    {        
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var out_mask = newShiftedMask(baseTarget, this.startBit);
        if (or_with_next)
            out_mask.orEquals(or_with_next);
        return out_mask;
    }

    // Just return a shifted bitmask to use as args
    this.mask = function (mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        var out_mask = newShiftedMask(baseTarget, this.startBit);
        return bitFieldToInt(out_mask);
    }

    // Read and then sign-extend
    this.readSigned = function ()
    {
        var rval = this.read();
        rval <<= (32 - this.numBits);
        rval >>= (32 - this.numBits);
        return rval;
    }

    this.write = function (value, mask)
    {
        var baseTarget = (mask == null) ? this.baseMask : this.baseMask & mask;
        if (this.shiftedMask == null)
            this.shiftedMask = newShiftedMask(baseTarget, this.startBit);
        if (this.shiftedValue == null)
            this.shiftedValue = newShiftedMask(value, this.startBit);

        this.shiftedMask.set(0);
        this.shiftedMask.setBits(this.startBit, baseTarget, baseTarget);
        this.shiftedValue.set(0);
        this.shiftedValue.setBits(this.startBit, value, value);

        if (this.qReg.animateWidgets)
            this.qReg.staff.addInstructionAfterInsertionPoint('write', this.shiftedMask, this.shiftedValue, 0);
        else
            this.qReg.write(this.shiftedMask, this.shiftedValue);
    }

    // Testing to get a result which works with Shor's algorithm.
    this.invQFT_test2 = function()
    {
        for (bit1 = 0; bit1 < this.numBits; ++bit1)
        {
            var mask1 = 1 << bit1;
            var theta = -90.0;
            for (bit2 = bit1 + 1; bit2 < this.numBits - 1; ++bit2)
                theta *= 0.5;
            this.hadamard(mask1);
            for (bit2 = bit1 + 1; bit2 < this.numBits; ++bit2)
            {
                var mask2 = 1 << bit2;
                this.phase(theta, 0, mask1|mask2);
                theta *= 2.0;
            }
        }
    }
    this.invQFT_test1 = function()
    {
        for (bit1 = this.numBits - 1; bit1 >= 0; --bit1)
        {
            var mask1 = 1 << bit1;
            var theta = 90.0;
            for (bit2 = this.numBits - 1; bit2 >= bit1 + 1; --bit2)
            {
                var mask2 = 1 << bit2;
                this.phase(theta, 0, mask1|mask2);
                theta *= 0.5;
            }
            this.hadamard(mask1);
        }
    }

    this.invQFT = function(target_mask=~0)
    {
        this.QFT(target_mask, true)
    }

    this.QFT = function(target_mask=~0, flip_h=false)
    {
        this.qReg.qpu.QFT(this.mask(target_mask), flip_h);
    }

    this.Grover = function(conditionMask)
    {
        this.hadamard();
        this.not();
        this.cphase(180, ~0, conditionMask);
        this.not();
        this.hadamard();
    }

    // this += rhs
    this.add = function(rhs, extraConditionBits, extraNOTConditionBits, reverse_to_subtract, shiftRHS)
  {
        var anim = this.qReg.animateWidgets;
        if (!shiftRHS)
            shiftRHS = 0;

        // If rhs is a number, just buid the addition logic
        if (rhs.toFixed)
            return this.add_int(rhs << shiftRHS, extraConditionBits, extraNOTConditionBits);

        if (extraNOTConditionBits)
        {
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
            else
                this.qReg.not(extraNOTConditionBits);
        }

        // Save time by re-using instructions and bitfields
        if (this.add_instructions == null)
            this.add_instructions = [];
        if (this.add_bf != null && this.add_bf.length > 0 && this.add_bf[0].numBits < this.qReg.numQubits)
            this.add_bf = null;
        if (this.add_bf == null)
            this.add_bf = [];

        var instructions = [];
        if (this.slideMask == null)
            this.slideMask = NewBitField(this.maskBF, this.qReg.numQubits);
        if (this.shiftStrip == null)
            this.shiftStrip = NewBitField(this.slideMask);
        this.slideMask.set(this.maskBF);
        this.shiftStrip.set(this.maskBF);
        for (var i = 0; i < shiftRHS; ++i)
            this.shiftStrip.shiftLeft1();
        this.shiftStrip.andEquals(this.slideMask);
        if (this.aCond == null)
            this.aCond = NewBitField(this.slideMask);
        if (this.aTarg == null)
            this.aTarg = NewBitField(this.slideMask);
        if (this.condArg == null)
            this.condArg = NewBitField(this.slideMask);
        if (this.bCond == null)
            this.bCond = NewBitField(0, this.qReg.numQubits);
        this.bCond.set(0);
//        var bCondAndRhs = NewBitField(this.bCond);
        this.bCond.setBit(rhs.startBit, 1);  /**** Add the low bit of B first, then work your way up. ****/
        var shiftWait = 0;
    while (this.bCond.andIsNotEqualZero(rhs.maskBF))
        {
            this.aTarg.set(0);
            this.aTarg.setBit(this.startBit + (this.numBits - 1), 1);
            this.aCond.set(this.slideMask);
            this.aCond.shiftRight1();
            while (this.aTarg.andIsNotEqualZero(this.slideMask) && this.aTarg.andIsNotEqualZero(this.shiftStrip))
            {
                this.condArg.set(this.aCond);
                this.condArg.andEquals(this.slideMask);
                this.condArg.andEquals(this.shiftStrip);
                this.condArg.orEquals(extraConditionBits);
                this.condArg.orEquals(extraNOTConditionBits);
                this.condArg.orEquals(this.bCond);
                if (instructions.length == this.add_instructions.length)
                {
                    var inst = new QInstruction('cnot', this.aTarg, this.condArg, 0, null);
                    this.add_instructions.push(inst);
                    instructions.push(inst);
                }
                else
                {
                    // re-use existing instructions if we have them.
                    var inst = this.add_instructions[instructions.length];
                    inst.targetQubits.set(this.aTarg);
                    inst.conditionQubits.set(this.condArg);
                    instructions.push(inst);
                }
                this.aCond.shiftRight1();
                this.aTarg.shiftRight1();
      }
      this.bCond.shiftLeft1();
            this.slideMask.shiftLeft1();
            this.slideMask.andEquals(this.maskBF);
            this.shiftStrip.shiftLeft1();
            this.shiftStrip.andEquals(this.maskBF);
    }
        if (reverse_to_subtract)
        {
            if (anim)
            {
                for (var i = instructions.length - 1; i >= 0; --i)
                    this.qReg.staff.addInstructionAfterInsertionPoint(instructions[i]);
            }
            else
            {
                for (var i = instructions.length - 1; i >= 0; --i)
                    this.qReg.cnot(instructions[i].targetQubits, instructions[i].conditionQubits);
            }
        }
        else
        {
            if (anim)
            {
                for (var i = 0; i < instructions.length; ++i)
                    this.qReg.staff.addInstructionAfterInsertionPoint(instructions[i]);
            }
            else
            {
                for (var i = 0; i < instructions.length; ++i)
                    this.qReg.cnot(instructions[i].targetQubits, instructions[i].conditionQubits);
            }
        }

        if (extraNOTConditionBits)
        {
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
            else
                this.qReg.not(extraNOTConditionBits);
        }
  }

    // this += rhs << shift
    this.addShifted = function(rhs, shiftRHS, extraConditionBits, extraNOTConditionBits, reverse_to_subtract)
    {
        this.add(rhs, extraConditionBits, extraNOTConditionBits, reverse_to_subtract, shiftRHS);
    }

    // this += rhs * rhs
    this.addSquared = function(rhs, extraConditionBits, extraNOTConditionBits, reverse_to_subtract)
    {
        // If rhs is a number, just buid the addition logic
        if (rhs.toFixed)
            return this.add_int(rhs * rhs, extraConditionBits, extraNOTConditionBits);

        var slideMask = NewBitField(0, this.qReg.numQubits);
        for (var bit = 0; bit < rhs.numBits; ++bit)
        {
            slideMask.set(0);
            if (extraConditionBits)
                slideMask.orEquals(extraConditionBits);
            slideMask.setBit(rhs.startBit + bit, 1);
            this.add(rhs, slideMask, extraNOTConditionBits, reverse_to_subtract, bit);
            slideMask.shiftLeft1();
        }
    }

    // this = (this << shift) rotating bits back arounc
    this.reverseBits = function(extraConditionBits)
    {
        var mask = this.bits(0);
        var iters = Math.floor(this.numBits / 2);
        for (var i = 0; i < iters; ++i)
        {
            mask.set(0);
            mask.setBit(this.startBit + i, 1);
            mask.setBit(this.startBit + this.numBits - (i + 1), 1);
            this.qReg.staff.addInstructionAfterInsertionPoint('exchange', mask, extraConditionBits);
        }
    }

    // this = (this << shift) rotating bits back arounc
    this.rollLeft = function(shift, extraConditionBits, extraNOTConditionBits)
    {
        shift %= this.numBits;
        if (shift == 0)
            return;
        var mask = this.bits(0);
        // TODO: This is temporary and not optimal.
        var one_at_a_time = false;
        if (one_at_a_time)
        {
            var bit0 = 0;
            var bit1 = shift;
            for (var s = 0; s < shift; ++s)
            {
                for (var i = this.numBits - 2; i >= 0; --i)
                {
                    mask.set(0);
                    mask.setBit(this.startBit + ((i + 0) % this.numBits), 1);
                    mask.setBit(this.startBit + ((i + 1) % this.numBits), 1);
                    this.qReg.staff.addInstructionAfterInsertionPoint('exchange', mask, extraConditionBits);
                }
            }
        }
        else
        {
//            shift = this.numBits - shift;
            for (var i = this.numBits - 1; i > 0; --i)
            {
                mask.set(0);
                var buddy = Math.max(i - shift, 0);
                mask.setBit(this.startBit + i, 1);
                mask.setBit(this.startBit + buddy, 1);
                this.qReg.staff.addInstructionAfterInsertionPoint('exchange', mask, extraConditionBits);
            }
        }
    }

    // this -= rhs << shift
    this.subtractShifted = function(rhs, shiftRHS, extraConditionBits, extraNOTConditionBits, reverse_to_subtract)
    {
        if (rhs.toFixed)
            return this.add_int(-(rhs << shiftRHS), extraConditionBits, extraNOTConditionBits);
        this.addShifted(rhs, shiftRHS, extraConditionBits, extraNOTConditionBits, true);
    }

    // this += rhs * rhs
    this.subtractSquared = function(rhs, extraConditionBits, extraNOTConditionBits, reverse_to_subtract)
    {
        if (rhs.toFixed)
            return this.add_int(-(rhs * rhs), extraConditionBits, extraNOTConditionBits);
        this.addSquared(rhs, extraConditionBits, extraNOTConditionBits, true);
    }

    this.negate = function ()
    {
         this.not();
         this.add(1);
    }

    this.subtract = function (rhs, extraConditionBits, extraNOTConditionBits)
    {
        if (rhs.toFixed)
            return this.add_int(-rhs, extraConditionBits, extraNOTConditionBits);
        // Just add the number, but backwards.
        this.add(rhs, extraConditionBits, extraNOTConditionBits, true);
    }

    // this += rhs
    // extraConditionBits is any bits which we want to add as conditions
    this.add_int = function(rhs, extraConditionBits, extraNOTConditionBits)
    {
        // Optimization while writing QQFSM(bf) whitepaper:
        // If the high bit is set, it's going to be faster to negate the int
        // and just run the addition backwards.
        var anim = this.qReg.animateWidgets;

        var reverse = false;
        if (this.numBits > 1
            && (rhs & (1 << (this.numBits - 1))))
        {
            reverse = true;
            rhs = -rhs & this.baseMask;
        }
        var instructions = [];
        // Save time by re-using instructions and bitfields
        if (this.add_instructions == null)
            this.add_instructions = [];

        if (extraNOTConditionBits)
        {
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
            else
                this.qReg.not(extraNOTConditionBits);
        }
        rhs = 0|rhs;    // Force it to be an integer
        var rhs_mask = 0;
        while (rhs & ~rhs_mask)
            rhs_mask = (rhs_mask << 1) | 1;
        rhs_mask &= this.baseMask;

        if (this.slideMask == null)
            this.slideMask = NewBitField(this.maskBF, this.qReg.numQubits);
        if (this.aCond == null)
            this.aCond = NewBitField(this.slideMask);
        if (this.aTarg == null)
            this.aTarg = NewBitField(this.slideMask);
        if (this.condArg == null)
            this.condArg = NewBitField(this.slideMask);
        this.slideMask.set(this.maskBF);
        var bCond = 1;  /**** Add the low bit of B first, then work your way up. ****/
        while (bCond & rhs_mask)
        {
            this.aTarg.set(0);
            this.aTarg.setBit(this.startBit + (this.numBits - 1), 1);
            this.aCond.set(this.slideMask);
            this.aCond.shiftRight1();
            while (this.aTarg.andIsNotEqualZero(this.slideMask))
            {
                if (rhs & bCond)
                {
                    this.condArg.set(this.aCond);
                    this.condArg.andEquals(this.slideMask);
                    this.condArg.orEquals(extraConditionBits);
                    this.condArg.orEquals(extraNOTConditionBits);
                    if (instructions.length == this.add_instructions.length)
                    {
                        var inst = new QInstruction('cnot', this.aTarg, this.condArg, 0, null);
                        this.add_instructions.push(inst);
                        instructions.push(inst);
                    }
                    else
                    {
                        // re-use existing instructions if we have them.
                        var inst = this.add_instructions[instructions.length];
                        inst.targetQubits.set(this.aTarg);
                        inst.conditionQubits.set(this.condArg);
                        instructions.push(inst);
                    }
                }
                this.aCond.shiftRight1();
                this.aTarg.shiftRight1();
            }
            bCond <<= 1;
            this.slideMask.shiftLeft1();
            this.slideMask.andEquals(this.maskBF);
        }

        if (reverse)
        {
            if (anim)
            {
                for (var i = instructions.length - 1; i >= 0; --i)
                    this.qReg.staff.addInstructionAfterInsertionPoint(instructions[i]);
            }
            else
            {
                for (var i = instructions.length - 1; i >= 0; --i)
                    this.qReg.cnot(instructions[i].targetQubits, instructions[i].conditionQubits);
            }
        }
        else
        {
            if (anim)
            {
                for (var i = 0; i < instructions.length; ++i)
                    this.qReg.staff.addInstructionAfterInsertionPoint(instructions[i]);
            }
            else
            {
                for (var i = 0; i < instructions.length; ++i)
                    this.qReg.cnot(instructions[i].targetQubits, instructions[i].conditionQubits);
            }
        }

        if (extraNOTConditionBits)
        {
            if (anim)
                this.qReg.staff.addInstructionAfterInsertionPoint('not', extraNOTConditionBits, 0, 0);
            else
                this.qReg.not(extraNOTConditionBits);
        }
    }



    // Now actually reserve it (at construction time)
    this.reserve();
}

  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC100: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

function QUInt(numBits, qReg, name)
{
    Qubits.call( this, numBits, qReg, name);
}
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC101: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

function QInt(numBits, qReg, name)
{
    QUInt.call( this, numBits, qReg, name);

    this.read = function (mask)
    {
        var result = this.read_uint(mask);

        // Now make it signed
        high_bit = 1 << (this.numBits - 1)
        if (result & high_bit)
        {
            // sign-extend
            result |= (-1 << this.numBits);
        }
        return result;
    }
    this.read_int = this.read;
    this.write_int = this.write;
}
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC102: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

function QFixed(numBits, radix, qReg, name)
{
    QInt.call( this, numBits, qReg, name);
    this.radix = radix;

    this.read = function (mask)
    {
        var value = this.read_int(mask);
        value /= (1.0 * (1 << this.radix));
        return value;
    }
    this.write = function (value, mask)
    {
        value = 0|(value * (1 << this.radix))
        this.write_int(value, mask);
    }
}
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC103: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

function is_qint(value)
{
    // Check to see if a variable is a qint (otherwise it's likely a bitfield or an integer)
    return value != null && value.startBit != null;
}
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC104: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

// Given an array of qints and masks, return a bitfield which is a combined mask.
// Input is like this:
//    qintBits([intA, maskA, intB, maskB, ...]);
function qintMask(list)
{
    var numBits = 1;
    if (list[0])
        numBits = list[0].qReg.numQubits;
    var result = NewBitField(0, numBits);
    for (var index = 0; index < list.length; index += 2)
    {
        var qint = list[index];
        if (qint)
        {
            var mask = list[index + 1];
            result.orEquals(qint.bits(mask));
        }
    }
    return result;
}
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorC105: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }

// Node.js hookups
module.exports.is_qint = is_qint;
module.exports.Qubits = Qubits;
module.exports.QInt = QInt;
module.exports.QUInt = QUInt;
module.exports.QFixed = QFixed;

 </script>










<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorD: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_basicops.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorE: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_widgets.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorF: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_staff.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorG: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_scriptpanel.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorH: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>
<script type="text/javascript" src="https://machinelevel.github.io/QCEngine/src/qcengine_panel.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorI: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>

<script type="text/javascript" src="./sample_shortcuts.js"></script>
<script>
  window.onerror = function(message, source, lineno, colno, error)
  { alert('ErrorJ: ' + message + ' src:' + source + ' line:' + lineno + ' col:' + colno); }
</script>

    <style>
        .panel-resizable {
            resize: vertical;
          overflow: auto;
        }

        .ej-no-margin {
          margin: 0px !important;
/*          margin-bottom:50px !important;
*/           padding: 0px !important;
          padding-bottom:10px !important;
        }

        .xxxpad-left-only {
          margin: 0px !important;
/*           padding: 8px !important;
           padding-left: 10px !important;
           padding-right: 0px !important;
           margin: 0px !important;
           margin-left: 10px;
*/        }
        .xxxpad-right-only {
           padding: 8px !important;
/*           padding-left: 0px !important;
           padding-right: 10px !important;
           margin: 0px !important;
           margin-right: 10px;
*/        }
        .less-padding {
           padding: 0px !important;
           margin: 0px !important;
        }
        .ej-btn-cstyle {
           padding: 4px !important;
        }

        .editor {
/*          background-color:#e5e5e5;
          padding:0px;
          margin-top:1%;
          margin-left:1%;
          margin-right:1%;
          margin-bottom:1%;
          float:bottom;
          width:98%;
*/          
/*          resize:vertical;
          overflow:auto;
*/
          overflow: hidden;
          width:100%;
          height:400px;
        }

         .info-button {
         background-color: #1c87c9;
         border: none;
         color: white;
         padding: 5px 8px;
         text-align: center;
         text-decoration: none;
         display: inline-block;
         font-size: 16px;
         margin: 4px 2px;
         cursor: pointer;
         }
    </style>

</head>
<body>
 <div id="info-buttons-div" style="position:absolute; left:0px; top:0px;">
  <table cellpadding="10">
    <tr>
      <td colspan="3">
        <img src="images/cs-title-bar-spacer.png" style="width:100%;" />
      </td>
    </tr>
    <tr>
      <td style="width:60%;">
      </td>
      <td>
    <a href="https://shop.oreilly.com/product/0636920167433.do" class="info-button" target="_blank">Book Info</a>
  </td>
      <td>
    <a href="https://www.amazon.com/Programming-Quantum-Computers-Essential-Algorithms/dp/1492039683" class="info-button" target="_blank">Buy on Amazon</a>
  </td>
</tr>
</table>
</div>
<div id="title-div">
        <img src="images/cs-title-bar.jpg" width="100%" />
</div>

<br/>

<div class="row">
  <div class="col-sm-6">
    <div class="container-fluid pad-left-only">

      <div class="panel panel-default">
        <div class="panel-heading">

          <div class="btn-group">
            <button type="button" class="btn btn-success" onclick="handle_run_button();">
              <span class="glyphicon glyphicon-play"></span>
              Run Program
            </button>
            <div class="btn-group">
              <span id="example_choice_span">
                <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
                Choose a sample <span class="caret"></span></button>
                <ul class="dropdown-menu" role="menu">
                </ul>
              </span>
            </div>
            <div class="btn-group">
              <span id="engine_choice_span">
                <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
                QCEngine <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" role="menu">
                </ul>
              </span>
            </div>
          </div>


          <div class="btn-group">
            <button type="button" class="btn btn-default" onclick="click_editor_zoom(-2);">
              <span class="glyphicon glyphicon-zoom-out"></span>
            </button>
            <button type="button" class="btn btn-default" onclick="click_editor_zoom(2);">
              <span class="glyphicon glyphicon-zoom-in"></span>
            </button>
          </div>

          <img src="images/icon_question.png" title="About QCEngine" height=20 onclick="do_aboutqce_modal();" />
          <img src="images/icon_cheatsheet.png" title="Command cheat sheet" height=20 onclick="do_cheatsheet_modal();" />

          <span id="bug_span">
          </span>
          <span id="info_span">
          </span>
          <span id="example_github_span">
          </span>

          <span id="sample_info_span" style="display:none;">
            <img src="images/caution.png" height="28" />
            <b>This sample takes a while to run.</b>
          </span>
        </div>

        <div id="editor_boot_panel" class="panel-body panel-resizable ej-no-margin">
          <div id="editor_div" class="editor"></div>
        </div>
      </div>


    </div>
  </div>
  <div class="col-sm-6">
    <div class="container-fluid pad-right-only">
      <div class="row">



        <div id="progress_panel" class="col-*-*" style="display:none;">
          <div class="container-fluid pad-right-only">
              <div class="progress">
                <div id="progress_bar" class="progress-bar" role="progressbar" style="width: 25%;" aria-valuenow="25" aria-valuemin="0" aria-valuemax="100">25%</div>
              </div>
          </div>
        </div>


        <div class="col-*-*" style="display:none;">
          <div class="container-fluid pad-right-only">
            <div class="panel panel-default">
              <div class="panel-heading">
                <b>How to run this sample</b>
                  <div class="btn-group">

<!--                     <span id="example_language_span">
                      <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
                      Choose a Language <span class="caret"></span>
                      </button>
                      <ul class="dropdown-menu" role="menu">
                      </ul>
                    </span>
 -->
                  </div>
                <div class="btn-group">
                  <button type="button" class="btn btn-default" onclick="click_gate_zoom(-1);">
                    <span class="glyphicon glyphicon-zoom-out"></span>
                  </button>
                  <button type="button" class="btn btn-default" onclick="click_gate_zoom(1);">
                    <span class="glyphicon glyphicon-zoom-in"></span>
                  </button>
                </div>
              </div>
              <div  id="how_to_boot_panel" class="panel-body panel-resizable">

                <span id="how-to-span">(text goes here)</span>


              </div>
            </div>
          </div>
        </div>


        <div id="image_output_div" class="col-*-*" style="display:none;">
          <div class="container-fluid pad-right-only">
            <div class="panel panel-default">
              <div class="panel-heading">
                <b>Image output</b>
                  <div class="btn-group">

<!--                     <span id="example_language_span">
                      <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
                      Choose a Language <span class="caret"></span>
                      </button>
                      <ul class="dropdown-menu" role="menu">
                      </ul>
                    </span>
 -->
                  </div>
              </div>
              <div  id="image_boot_panel" class="panel-body panel-resizable">

                <span id="image_info_span"></span>
                <table id="images_table">
                  <tr>
                    <td align="center" style="padding: 10px; border: 4px solid #ddd;">
                      <canvas id="display_ground_truth"></canvas><br/>
                      <span id="display_ground_truth_span"></span>
                    </td>
                    <td align="center" style="padding: 10px; border: 4px solid #ddd;">
                      <canvas id="display_qfull_res"></canvas><br/>
                      <span id="display_qfull_res_span"></span>
                    </td>
                  </tr>
                  <tr>
                    <td align="center" style="padding: 10px; border: 4px solid #ddd;">
                      <canvas id="display_monte_carlo"></canvas><br/>
                      <span id="display_monte_carlo_span"></span>
                    </td>
                    <td align="center" style="padding: 10px; border: 4px solid #ddd;">
                      <canvas id="display_qss"></canvas><br/>
                      <span id="display_qss_span"></span>
                    </td>
                  </tr>
                  <tr>
                    <td align="center" style="padding: 10px; border: 4px solid #ddd;">
                      <canvas id="display_confidence"></canvas><br/>
                      <span id="display_confidence_span"></span>
                    </td>
                  </tr>
                </table>
                <table>
                  <tr>
                    <td colspan="2" align="center" style="padding: 10px; border: 4px solid #ddd;">
                      <canvas id="display_cwtable"></canvas><br/>
                      <span id="display_cwtable_span"></span>
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          </div>
        </div>




        <div class="col-*-*">
          <div class="container-fluid pad-right-only">
            <div class="panel panel-default">
              <div class="panel-heading">
                <b>Program gates</b>
                <div class="btn-group">
                  <button type="button" class="btn btn-default" onclick="click_gate_zoom(-1);">
                    <span class="glyphicon glyphicon-zoom-out"></span>
                  </button>
                  <button type="button" class="btn btn-default" onclick="click_gate_zoom(1);">
                    <span class="glyphicon glyphicon-zoom-in"></span>
                  </button>
                </div>

<!--                 <button type="button" class="btn btn-default">
                    <span class="glyphicon glyphicon-new-window"></span>
                </button>
 -->
              </div>
              <div  id="staff_boot_panel" class="panel-body panel-resizable">



                <div id="staff_popin_div" class="right" style="resize: both; overflow: auto;">
<!--                  <img src="images/click_tag.png" height="32" /><br/> -->
                  <canvas id="draw_gate_canvas"></canvas>
                </div>





              </div>
            </div>
          </div>
        </div>
        <div class="col-*-*">
          <div class="container-fluid pad-right-only">
            <div class="panel panel-default">
              <div class="panel-heading">
                <b>State vector</b>
                <div class="btn-group">
                  <button type="button" class="btn btn-default" onclick="click_circle_zoom(-1);">
                    <span class="glyphicon glyphicon-zoom-out"></span>
                  </button>
                  <button type="button" class="btn btn-default" onclick="click_circle_zoom(1);">
                    <span class="glyphicon glyphicon-zoom-in"></span>
                  </button>
                </div>
                <div class="btn-group">
                  <button type="button" class="btn btn-default ej-btn-cstyle">
                    <img src="images/circ_style_00a.png" width="40" onclick="click_circle_style(0);"></span>
                  </button>
                  <button type="button" class="btn btn-default ej-btn-cstyle">
                    <img src="images/circ_style_01a.png" width="40" onclick="click_circle_style(1);"></span>
                  </button>
                  <button type="button" class="btn btn-default ej-btn-cstyle">
                    <img src="images/circ_style_10a.png" width="40" onclick="click_circle_style(2);"></span>
                  </button>
                  <button type="button" class="btn btn-default ej-btn-cstyle">
                    <img src="images/circ_style_11a.png" width="40" onclick="click_circle_style(3);"></span>
                  </button>
                </div>

<!--                 <button type="button" class="btn btn-default">
                    <span class="glyphicon glyphicon-new-window"></span>
                </button>
 -->
              </div>
              <div  id="circle_boot_panel" class="panel-body panel-resizable">

                <div id="circle_div" class="right" style="resize: both; overflow: auto;">
                  <canvas id="circle_canvas"></canvas>
                </div>


              </div>
            </div>



      <div class="panel panel-default">
        <div class="panel-heading">
                <b>Program output</b>

          <div class="btn-group">
            <button type="button" class="btn btn-default" onclick="click_output_zoom(-1);">
              <span class="glyphicon glyphicon-zoom-out"></span>
            </button>
            <button type="button" class="btn btn-default" onclick="click_output_zoom(1);">
              <span class="glyphicon glyphicon-zoom-in"></span>
            </button>
          </div>
          <div class="btn-group">
            <button type="button" class="btn btn-default" onclick="clear_output(false);" title="Clear output">
              <span class="glyphicon glyphicon-erase"></span>
            </button>
          </div>
        </div>
        <div class="panel-body panel-resizable">
          <textarea id="script_output_textarea" style="font-family:monospace; font-size:12pt; width:100%; height:100px; resize:both;">
(program output goes here)
          </textarea>
        </div>
      </div>




          </div>
        </div>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="AboutQCE_runModal" tabindex="-1" role="dialog" aria-labelledby="AboutQCE_runModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="AboutQCE_runModalLabel">QCEngine Notes</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        QCEngine is intended to be a lightweight quantum computation simulator,
        useful for quick sketches and demonstrations.

        <br/>
        <br/>
        It will let you run JavaScript code, simulating the quantum computing as
        though you had a real QC, up to about 25 qubits (depending on your browser).
        The best way to get familiar with QCEngine is to run the book samples on
        this page.
        <br/>
        <br/>
        For more serious development tasks, there are many other simulation engines available:
        <br/>
        <ul>
          <li><b><a href="qiskit.org" target="_default">Qiskit</a></b> - 
            An open-source software development kit (SDK) for working with OpenQASM and the
            IBM Q quantum processors. Create quantum computing programs, compile, and execute them online
            in a real quantum processors.</li>
          <li><b><a href="https://quantum-computing.ibm.com" target="_default">IBM Q Experience</a></b> - 
            A complete online environment, containing tools and information for programming quantum
            simulations as well as physical quantum computers.</li>
          <li><b><a href="https://www.microsoft.com/en-us/quantum/development-kit" target="_default">Microsoft QDK</a></b> - 
            A complete software development system for developing and running programs for quantum computers.</li>
          <li><b><a href="http://www.quantumplayground.net" target="_default">Google QC Playground</a></b> - 
            An approachable online environment for discovering quantum computing.</li>
        </ul>

        ...just to name a few.
        <br/>
        <br/>
        If you have questions or comments
        about running these book samples, the authors would love to hear from you
        at <b><a href="mailto:octopus@qcengine.com">octopus@qcengine.com</a></b>.
              </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="CheatSheet_runModal" tabindex="-1" role="dialog" aria-labelledby="CheatSheet_runModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="CheatSheet_runModalLabel">QCEngine Command Cheat Sheet</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        This sheet provides a quick-reference for most common QCEngine commands.
        The best way to become familiar with QCEngine commands is to try running the book
        samples in this page.
        If you find things missing or unclear, the authors would love to hear from you
        at <b><a href="mailto:octopus@qcengine.com">octopus@qcengine.com</a></b>.

        <br/>
        <br/>
        <b>"qc." Commands:</b> Commands such as <code>qc.reset()</code> and <code>qc.cnot(t,c)</code> execute
        using a quantum computation simulator. In most cases, they take a <b>target mask</b> and a <b>condition mask</b>,
        to specify which qubits the instructions act on. Some commands also take a rotation angle.

        <br/>
        <br/>
        <b>Qubit Masks:</b> Qubits are be specified using an integer, where each bit corresponds to one of the
        qubits in the quantum computer.

        <br/>
        <br/>
        (...this is under sonstruction)
        
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="AddEngine_runModal" tabindex="-1" role="dialog" aria-labelledby="AddEngine_runModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="AddEngine_runModalLabel">Add new engines and samples!</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <b>Have a favorite quantum simulator, or even a real QPU?</b>
        <br/>
        We'd love to add your sample code here.
        <br/>
        <br/>
        Providing these samples for as many systems as possible helps our readers, so please contact us
        at <b><a href="mailto:octopus@qcengine.com">octopus@qcengine.com</a></b>.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="Qiskit_runModal" tabindex="-1" role="dialog" aria-labelledby="Qiskit_runModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="Qiskit_runModalLabel">Running Qiskit Sample Code</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        The Qiskit versions of examples in this book are written in Python, designed to run
        as Qiskit notebooks, at <a href="https://qiskit.org" target="_blank">https://qiskit.org</a>.
        <br/><br/>
        Qiskit is an open-source software development kit (SDK) for working with OpenQASM and the
        IBM Q quantum processors. Create quantum computing programs, compile, and execute them online
        in a real quantum processors.
        <br/><br/>
        To run this sample, go to the Qiskit site and create a new notebook, and then paste this
        sample code into it.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <button type="button" class="btn btn-success" onclick="window.open('https://qiskit.org', '_blank');">Go to Qiskit.org</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="QASM_runModal" tabindex="-1" role="dialog" aria-labelledby="QASM_runModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="QASM_runModalLabel">Running QASM Sample Code</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        The OpenQASM versions of examples in this book are designed to run
        using the <b>IBM Q Experience Quantum Composer</b>, at <a href="https://quantum-computing.ibm.com" target="_blank">https://quantum-computing.ibm.com</a>.
        <br/><br/>
        The <b>Quantum Composer</b> is a graphical user interface for programming a quantum processor.
        <br/><br/>
        To run this sample, go to the Q Experience site and create new circuit using the Circuit Composer,
        then paste the code into the Circuit Editor.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <button type="button" class="btn btn-success" onclick="window.open('https://quantum-computing.ibm.com', '_blank');">Go to IBM Q Experience</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="QSharp_runModal" tabindex="-1" role="dialog" aria-labelledby="QSharp_runModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="QSharp_runModalLabel">Running Q# Sample Code</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        The Q# (pronounced "Q Sharp") versions of examples in this book are designed to run
        using the <b>Microsoft QDK</b>, at <a href="https://www.microsoft.com/en-us/quantum/development-kit" target="_blank">https://www.microsoft.com/en-us/quantum/development-kit</a>.
        <br/><br/>
          Q# is a quantum-focused programming language with native type, operators, and other abstraction.
        <br/><br/>
        To run this sample, go to the QDK site and create a new IQ# Notebook, and then paste this
        sample code into it.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <button type="button" class="btn btn-success" onclick="window.open('https://www.microsoft.com/en-us/quantum/development-kit', '_blank');">Go to QDK Website</button>
      </div>
    </div>
  </div>
</div>


<script>
    var editor = ace.edit("editor_div");
    editor.session.setMode("ace/mode/javascript");
    editor.commands.addCommand({
        name: "run",
        bindKey: {win: "Shift-Enter", mac: "Shift-Enter"},
        exec: function(editor) {
            handle_run_button();
        }
    });

var editor_div = document.getElementById('editor_div');
var editor_boot_panel = document.getElementById('editor_boot_panel');
var staff_boot_panel = document.getElementById('staff_boot_panel');
var circle_boot_panel = document.getElementById('circle_boot_panel');
var editor_frame_div = document.getElementById('editor_frame_div');
var example_choice_span = document.getElementById('example_choice_span');
var engine_choice_span = document.getElementById('engine_choice_span');
var example_github_span = document.getElementById('example_github_span');
// var language_choice_span = document.getElementById('language_choice_span');
var script_output_textarea = document.getElementById('script_output_textarea');
var staff_popin_div = document.getElementById('staff_popin_div');

function show_info(message)
{
    var span = document.getElementById('info_span');
    var sstr = span.innerHTML;
    if (message)
    {
        sstr += '<br/>';
        sstr += message;
    }
    span.innerHTML = sstr;
}

function show_bug(enable, err)
{
    var span = document.getElementById('bug_span');
    var sstr = '';
    if (enable)
    {
        sstr += '<br/>';
        sstr += '<span style="color:darkred;">';
        sstr += '<img src="images/icon_bug.png" height="20" /> '
        sstr += '<b>Error:</b> ' + err.message;
        sstr += '</span>';
    }
    span.innerHTML = sstr;
}

show_info('001');

///////////////////////////////////////////////////////////////
// This is a small workaround for the issue where the editor
// doesn't get informed about size changes
var last_editor_div_width = 0;
var last_editor_div_height = 0;
var last_circle_div_width = 0;
var last_circle_div_height = 0;
var check_serial = 0;

function check_for_editor_resize()
{
    // Editor
    var w = editor_boot_panel.offsetWidth;
    var h = editor_boot_panel.offsetHeight;
    if (w != last_editor_div_width || h != last_editor_div_height)
    {
        editor_div.style.height = "" + (h - 10) + "px";
        editor.resize();
        last_editor_div_width = w;
        last_editor_div_height = h;
    }

    // Circle chart
    var w = circle_boot_panel.offsetWidth;
    var h = circle_boot_panel.offsetHeight;
    if (w != last_circle_div_width || h != last_circle_div_height)
    {
        qc_options.circle_div.width = w;
        qc_options.circle_div.height = h;
        qc.panel_chart.draw();
        last_circle_div_width = w;
        last_circle_div_height = h;
    }

    var seconds_per_check_for_editor_resize = 0.5;
    window.setTimeout(check_for_editor_resize,
                      1000 * seconds_per_check_for_editor_resize);
}
/*
window.onload = function() {
    show_info('101');
    check_for_editor_resize();
    show_info('102');
    fetch_sample_contents();
    show_info('103');
    make_sample_menu();
    show_info('104');
};
*/
function click_circle_style(style)
{
  if (style == 0)
  {
    qc_options.color_by_phase = false;
    qc_options.book_render = false;
  }
  else if (style == 1)
  {
    qc_options.color_by_phase = false;
    qc_options.book_render = true;
  }
  else if (style == 2)
  {
    qc_options.color_by_phase = true;
    qc_options.book_render = false;
  }
  else if (style == 3)
  {
    qc_options.color_by_phase = true;
    qc_options.book_render = true;
  }
  qc.panel_chart.draw();
}

function click_editor_zoom(up_down)
{
  var editor_fontsize = parseInt(editor.getOption('fontSize'));
  if (up_down == 0)
    editor_fontsize = 12;
  else
    editor_fontsize += up_down;
  if (editor_fontsize < 4)
    editor_fontsize = 4;
  editor.setOptions({fontSize: '' + editor_fontsize + 'pt'});
}

function click_gate_zoom(up_down)
{
  var old_scale = qc.get_param('draw_scale', 1.0);
  var new_scale = 1.0;
  if (up_down == 1)
    new_scale = old_scale * 1.1;
  if (up_down == -1)
    new_scale = old_scale / 1.1;
  qc.set_param('draw_scale', new_scale);
  qc.draw();
}

function click_circle_zoom(up_down)
{
  var e = {ctrlKey:true, shiftKey:false, deltaY:-up_down};

  list = qc.panel_chart.widgets;
  for (var i = 0; i < list.length; ++i)
  {
    var widget = list[i];
    list[i].mouseWheel(e);
  }
}

function click_output_zoom(up_down)
{
  var fontsize = parseInt(script_output_textarea.style.fontSize);
  if (up_down == 0)
    fontsize = 12;
  else
    fontsize += up_down;
  if (fontsize < 4)
    fontsize = 4;
  script_output_textarea.style.fontSize = '' + fontsize + 'pt';
}


show_info('cut5');






function load_json_from_url(file_url)
{
    fetch(file_url, {cache: 'reload'})
      .then(
        function(response) {
          if (response.status !== 200) {
            console.log('Looks like there was a problem. Status Code: ' + response.status);
            return false;
          }

          response.json().then(function(data) {
            console.log(data);
          });
          return true;
        }
      )
      .catch(function(err) {
        console.log('Fetch Error :-S', err);
        return false;
      });
}

function load_code_from_url(file_url)
{
    var use_fetch = false; // fetch is not supported on Kindles
    if (use_fetch)
    {
        fetch(file_url, {cache: 'reload'})
          .then(
            function(response) {
              if (response.status !== 200) {
                console.log('Error loading ' + file_url + '. Status Code: ' + response.status);
                return false;
              }
              response.text().then(function(data) {
                editor.focus();
                editor.setValue(data);
                editor.gotoLine(0);
              });
              return true;
            }
          )
          .catch(function(err) {
            console.log('Fetch Error :-S', err);
            return false;
          });
    }
    else
    {
        var http_request = new XMLHttpRequest();
        http_request.open('GET', file_url, true);

        // If specified, responseType must be empty string or "text"
        http_request.responseType = 'text';

        http_request.onload = function ()
        {
            if (http_request.readyState === http_request.DONE)
            {
                if (http_request.status === 200)
                {
                    // console.log(http_request.response);
                    // console.log(http_request.responseText);
                    editor.focus();
                    editor.setValue(http_request.responseText);
                    editor.gotoLine(0);
                    make_github_source_links();
                    make_engine_menu();
                }
                else
                {
                  do_failed_load_sample(file_url);
                }
            }
        };
        http_request.onerror = function ()
        {
          do_failed_load_sample(file_url);
        };
        try {
          http_request.send(null);
        }
        catch (error) {
          do_failed_load_sample(file_url);
        }
        return true;
    }
    make_github_source_links();
    make_engine_menu();
}

function do_failed_load_sample(file_url)
{
  var code_str = '// The sample ' + file_url + '\n// could not be loaded.\n//\n';
  code_str += '// (basic teleportation sample follows)\n\n';
  code_str += default_program;
  editor.focus();
  editor.setValue(code_str);
  editor.gotoLine(0);
  make_github_source_links();
  make_engine_menu();
}

show_info('002');

qc_options.staff_canvas = document.getElementById('draw_gate_canvas');
qc_options.staff_div = document.getElementById('staff_popin_div');
qc_options.circle_canvas = document.getElementById('circle_canvas');
qc_options.circle_div = document.getElementById('circle_div');
var valid_engine_list = [];
//qc_options.draw_scale = 3.0;
show_info('003');
try {
var qc = QPU();
}
catch (err) {
  show_bug(true, err);
}
show_info('004');
qc.set_param('draw_scale', 1.0);
show_info('005');
// qc.set_canvas(document.getElementById('draw_gate_canvas'));
// panel_staff = qc.panel_staff;
// panel_chart = qc.panel_chart;

var current_sample = null;
var current_engine = engine_list[0];
var all_sample_contents = {};
function fetch_one_sample_dir(engine)
{
    var base_url = 'https://api.github.com/repos/oreilly-qc/oreilly-qc.github.io/contents/samples/';
    var http_request = new XMLHttpRequest();
    http_request.open('GET', base_url + engine.name, true);

    // If specified, responseType must be empty string or "text"
    http_request.responseType = 'text';

    http_request.onload = function ()
    {
        if (http_request.readyState === http_request.DONE)
        {
            if (http_request.status === 200)
            {
                engine.dir_list = http_request.responseText;
                make_github_source_links();
                make_engine_menu();
            }
            else
            {
                engine.dir_list = '';
            }
        }
    };
    http_request.send(null);
}
show_info('cut7');
/*

function fetch_sample_contents()
{
    for (var i = 0; i < engine_list.length; ++i)
        fetch_one_sample_dir(engine_list[i]);
}

function make_sample_menu()
{
    str = '';
    str += '<button id="sample_menu_button" type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">';
    str += 'Choose a sample <span class="caret"></span></button>';
    str += '<ul class="dropdown-menu" role="menu">';
    for (i = 0; i < sample_menu.length; ++i)
    {
        sample = sample_menu[i];
        str += '<li><a href="#" onclick="choose_sample_menu(sample_menu['+i+'], null);">';
        str += sample.menu_title;
        str += '</a></li>';
    }
    str += '</ul>'
    example_choice_span.innerHTML = str;
    try_to_get_program_from_passed_in_url();
}

function set_current_engine(engine)
{
    if (engine == null)
        engine = engine_list[0];
    current_engine = engine;
    if (current_engine.name == 'QCEngine')
    {
        editor.session.setMode("ace/mode/javascript");
    }
    else if (current_engine.name == 'Qiskit')
    {
        editor.session.setMode("ace/mode/python");
    }
    else if (current_engine.name == 'OpenQASM')
    {
        editor.session.setMode("ace/mode/plain_text");
    }
    else if (current_engine.name == 'QSharp')
    {
        editor.session.setMode("ace/mode/plain_text");
    }
}

function choose_sample_menu(sample, engine=null)
{
  do_sample_special_cases(sample.shortcut);
  console.log('Sample menu chosen: ' + sample.sample_file);
  if (engine == null)
    engine = engine_list[0];
  set_current_engine(engine);
  var sample_menu_button = document.getElementById('sample_menu_button');
  sample_menu_button.innerHTML = sample.menu_title;
  load_code_sample(sample.sample_file, engine);
  var engine_menu_button = document.getElementById('engine_menu_button');
  if (engine_menu_button)
      engine_menu_button.innerHTML = engine.name;
  clear_output();
}

function choose_engine_menu(engine)
{
  console.log('Engine menu chosen: ' + engine.name);
  var engine_menu_button = document.getElementById('engine_menu_button');
  engine_menu_button.innerHTML = engine.name;
  set_current_engine(engine);
  load_code_sample(current_sample.sample_file, engine);
  clear_output();
}

function make_engine_menu()
{
    str = '';
    str += '<button id="engine_menu_button" type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">';
    str += 'Choose an engine <span class="caret"></span></button>';
    str += '<ul class="dropdown-menu" role="menu">';
    for (i = 0; i < valid_engine_list.length; ++i)
    {
        var engine_index = valid_engine_list[i];
        engine = engine_list[engine_index];
        str += '<li><a href="#" onclick="choose_engine_menu(engine_list['+engine_index+']);">';
        str += engine.name;
        str += '</a></li>';
    }
    str += '</ul>'
    engine_choice_span.innerHTML = str;
    var engine_menu_button = document.getElementById('engine_menu_button');
    engine_menu_button.innerHTML = current_engine.name;
}

function do_engine_modal()
{
    var options = null;
    var val = $('#'+current_engine.name+'_runModal').modal(options);
}

function do_addengine_modal()
{
    var options = null;
    var val = $('#AddEngine_runModal').modal(options);
}

function do_aboutqce_modal()
{
    var options = null;
    var val = $('#AboutQCE_runModal').modal(options);
}

function do_cheatsheet_modal()
{
    var options = null;
    var val = $('#CheatSheet_runModal').modal(options);
}

function make_github_source_links()
{
    var sample = current_sample;
    valid_engine_list = [0];
    str = '<br/>';
//    if (sample != null)
    {
        str += 'View source in Github: ';
        for (i = 0; i < engine_list.length; ++i)
        {
            engine = engine_list[i];
            if (i > 0)
                str += ' / ';
            var sample_ok = engine.dir_list.includes(sample.sample_file);
            if (sample_ok)
            {
                var link = 'https://github.com/oreilly-qc/oreilly-qc.github.io/blob/master/samples/';
                link += engine.name + '/' + sample.sample_file + engine.suffix;
                str += '<b><a href="'+link+'" target="_blank">'+engine.link_name+'</a></b>';
                if (i > 0)
                  valid_engine_list.push(i);
            }
            else
            {
                str += '<span style="color:#aaa" title="This version is not implemented yet, but if you\'d like to add it, please contact us at octopus@qcengine.com">' + engine.link_name + '</span>';
            }
        }
        str += '<span style="font-size:8pt; color:#77a">';
        str += '<br/>Developers: Add your engine, or add a sample! <b><a href="#" onclick="do_addengine_modal();">Click here</a></b> for more info.';
        str += '</span>';
    }
    example_github_span.innerHTML = str;
}

// get_url_param() is adapted from JeffreyCrofte's work here: https://www.creativejuiz.fr/blog/en/javascript-en/read-url-get-parameters-with-javascript
function get_url_param(param)
{
  var vars = {};
  window.location.href.replace( location.hash, '' ).replace( 
    /[?&]+([^=&]+)=?([^&]*)?/gi, // regexp
    function( m, key, value ) { // callback
      vars[key] = value !== undefined ? value : '';
    }
  );
  if (param) {
    result = vars[param]
    if (!result)
      return null;
    // Strip stray # symbols
    result = result.replace('#','');
    return result;
  }
  return vars;
}

function get_sample_from_string(sample_str)
{
    for (var i = 0; i < sample_menu.length; ++i)
    {
        var sample = sample_menu[i];
        if (sample_str == sample.sample_file || sample_str == sample.shortcut)
            return sample;
    }
    return sample_menu[0];
}

function get_engine_from_string(engine_str)
{
    if (engine_str == null)
      engine_str = 'qcengine';
    for (var i = 0; i < engine_list.length; ++i)
    {
        var engine = engine_list[i];
        if (engine_str.toLowerCase() == engine.name.toLowerCase())
            return engine;
    }
    return engine_list[0];
}

function try_to_get_program_from_passed_in_url()
{
    var sample_str = get_url_param('p');
    var engine_str = get_url_param('e');

    var sample = get_sample_from_string(sample_str);
    var engine = get_engine_from_string(engine_str);

    // Special case: sample 4-1 in the book needs to appear in
    //               QASM by default.
    if (sample_str == '4-1' && engine_str == null)
      engine = get_engine_from_string('OpenQASM');
    do_sample_special_cases(sample_str);

    show_graphics_output(false);

    choose_sample_menu(sample, engine);
}

function do_sample_special_cases(sample_str)
{
    // Sample special cases
    var sample_info_span = document.getElementById("sample_info_span");
    sample_info_span.style.display = 'none';

    if (sample_str == '4-2')
    {
        // Takes a while to eat a chocodile
        var sstr = '<img src="images/caution.png" height="28" /><b>This sample takes a while to run.</b>';
        sample_info_span.innerHTML = sstr;
        sample_info_span.style.display = 'block';
    }
    else if (sample_str == '11-4' || sample_str == '11-5' || sample_str == '11-6')
    {
        // Takes a while to eat a chocodile
        var sstr = '<img src="images/caution.png" height="28" /><b>This sample takes a while to run.</b>';
        sstr += '<br/>For a video demo of quantum supersampling, <a href="https://vimeo.com/180284417" target="_blank">chick here</a>.';
        console.log(sstr);
        sample_info_span.innerHTML = sstr;
        sample_info_span.style.display = 'block';
    }
}

function show_graphics_output(do_show)
{
    var div = document.getElementById("image_output_div");
    if (do_show)
        div.style.display = 'block';
    else
        div.style.display = 'none';
}

function hide_qss_image_panes()
{
    document.getElementById('images_table').style.display = 'none';
}

function load_code_sample(sample_str, engine=null)
{
    var sample = get_sample_from_string(sample_str);
    current_sample = sample;

    var qce = engine_list[0];
    if (engine != null)
      qce = engine;
    var raw_qce_code_url = qce.subdir + sample.sample_file + qce.suffix;

    var github_links_str = '';

    ok = load_code_from_url(raw_qce_code_url);
    if (!ok)
    {
        var code_str = '// sample ' + raw_qce_code_url + ' could not be loaded.\n';
        editor.focus();
        editor.setValue(code_str);
        editor.gotoLine(0);
    }
    return ok;
}

// function test_cc(canvas, color)
// {
//     canvas.width = 200;
//     canvas.height = 200;

//     console.log(canvas);
//     var ctx = canvas.getContext('2d');
//     ctx.save();
//     {
//         ctx.fillStyle = color;
//         ctx.fillRect(0, 0, canvas.width, canvas.height);
//     }
//     ctx.restore();
// }

function run_script()
{
    qc_options.color_by_phase = false;
    qc_options.circle_scale = 0.5;
    qc.start();
    if (qc) {
//      qc.disableAnimation();
//      qc.enableRecording();
      qc.codeLabel('');
    }

    qc.enableAnimation();

    show_state_vector();
    try {
      show_bug(false);
      runQCScriptInTextArea('editor', 'script_output_textarea');
    }
    catch (err) {
      show_bug(true, err);
    }

    qc.qReg.changed();
    show_state_vector();
    qc.panel_staff.draw();
    qc.panel_chart.draw();

    qc.enableAnimation();
}

function clear_output(show_default_message=true)
{
  if (show_default_message)
    script_output_textarea.value = '(output prints here)\n';
  else
    script_output_textarea.value = '';
}

function rewind_to_beginning()
{
  // if (current_language != 'javascript')
  //   return;
  console.log('instructions: ' + qc.qReg.staff.insertionStart);
  qc.qReg.staff.rewind_insertion_to_start();
}

function show_state_vector()
{
  list = qc.panel_chart.widgets;
  for (var i = 0; i < list.length; ++i)
  {
    if (list[i].stateVector)
    {
      // console.log(list[i]);
      list[i].collapsed = false;
    }
    else if (list[i].blochSphere ||
             list[i].densityMatrix || 
             list[i].graphState || 
             list[i].stabilizerState ||
             list[i].drawQInt)
    {
        list[i].in_use = false;
    }
  }
}

function set_progress(percent, message)
{
    var progress_panel = document.getElementById('progress_panel');
    var progress_bar = document.getElementById('progress_bar');
    progress_panel.style.display = 'block';
    // console.log(progress_bar);
//    progress_bar['aria-valuenow'] = percent;
    percent = Math.round(percent);
    progress_bar.style.width = ''+percent+'%';
    progress_bar.setAttribute('aria-valuenow', percent);
    if (message)
        progress_bar.innerHTML = ''+percent+'%'+' ('+message+')';
    else
        progress_bar.innerHTML = ''+percent+'%';
}

function handle_run_button()
{
    if (current_engine.name != 'QCEngine')
    {
        do_engine_modal();
        return;
    }
    // set_progress(50, '');
    run_script();
    qc.panel_staff.setVisible(true);
    qc.panel_chart.setVisible(true);
    qc.panel_staff.staff.fullSnapshot();
}

show_info('020');

var default_program = `
qc.reset(3);
qc.write(0);
qc.had(0x1);
qc.cnot(0x2, 0x1);
`;

show_info('021');

*/









</script>
</body>
</html>
